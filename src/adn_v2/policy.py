from __future__ import annotations

from typing import Iterable

from .config import ADNConfig
from .models import (
    RiskLevel,
    SentinelSignal,
    GuardianSignal,
    ChainSnapshot,
    DefenseDecision,
)


class DefensePolicy:
    """
    Pure decision-making logic for ADN v2.

    It takes:
      - Sentinel AI v2 risk
      - Wallet Guardian risk
      - live chain snapshot

    and outputs a DefenseDecision without touching the network directly.
    """

    def __init__(self, config: ADNConfig) -> None:
        self._cfg = config

    def _combine_wallet_levels(self, guardian_signals: Iterable[GuardianSignal]) -> RiskLevel:
        """Combine many wallet risk levels into a single view."""
        worst = RiskLevel.NORMAL
        order = [RiskLevel.NORMAL, RiskLevel.ELEVATED, RiskLevel.HIGH, RiskLevel.CRITICAL]
        for signal in guardian_signals:
            if order.index(signal.level) > order.index(worst):
                worst = signal.level
        return worst

    def decide(
        self,
        chain: ChainSnapshot,
        sentinel: SentinelSignal,
        guardians: Iterable[GuardianSignal],
    ) -> DefenseDecision:
        wallet_level = self._combine_wallet_levels(guardians)

        # Map RiskLevel to numeric score
        level_score = {
            RiskLevel.NORMAL: 0.0,
            RiskLevel.ELEVATED: 0.3,
            RiskLevel.HIGH: 0.7,
            RiskLevel.CRITICAL: 1.0,
        }

        wallet_score = level_score[wallet_level]

        combined = (
            sentinel.risk_score * self._cfg.sentinel_weight
            + wallet_score * (1.0 - self._cfg.sentinel_weight)
        )

        # Extra bump if we're already reorging deeper than we like
        if chain.reorg_depth > self._cfg.max_safe_reorg_depth:
            combined = min(1.0, combined + 0.2)

        # Turn combined score back into RiskLevel
        if combined >= 0.9:
            final_level = RiskLevel.CRITICAL
        elif combined >= 0.7:
            final_level = RiskLevel.HIGH
        elif combined >= 0.4:
            final_level = RiskLevel.ELEVATED
        else:
            final_level = RiskLevel.NORMAL

        decision = DefenseDecision(
            final_level=final_level,
            combined_risk=combined,
            rationale="auto-generated by DefensePolicy",
            tags=[],
        )

        # Apply policy thresholds
        if combined >= self._cfg.hardened_threshold:
            decision.activate_hardened_mode = True
            decision.tags.append("hardened-mode")

        if combined >= self._cfg.pqc_threshold and self._cfg.pqc.enable_pqc_switch:
            decision.enforce_pqc = True
            decision.tags.append("pqc-switch")

        if final_level in (RiskLevel.HIGH, RiskLevel.CRITICAL):
            decision.tighten_peer_policy = True
            decision.delay_new_txs = True
            decision.broadcast_warning = True
            decision.tags.append("network-warning")

        return decision
